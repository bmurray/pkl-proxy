package main

import (
	"bufio"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"
)

const rewritesPklTemplate = `// Auto-generated by pkl-proxy. Do not edit manually.
// Run "pkl-proxy install <path>" or "pkl-proxy uninstall <path>" to manage entries.

local listenAddress = read?("env:PKL_PROXY_LISTEN_ADDRESS") ?? "{{ .ListenAddress }}"

local paths: Listing<String> = new {
{{- range .Paths }}
  "{{ . }}"
{{- end }}
}

rewrites: Mapping<String, String> = new {
  for (path in paths) {
    ["https://github.com/\(path)/"] = "http://\(listenAddress)/\(path)/"
    ["https://pkg.pkl-lang.org/github.com/\(path)/"] = "http://\(listenAddress)/\(path)/"
  }
}
`

const settingsPklTemplate = `amends "pkl:settings"

import "pkl-proxy/rewrites.pkl" as pklProxy

http {
  rewrites {
    for (key, value in pklProxy.rewrites) {
      [key] = value
    }
  }
}
`

var rewritesTmpl = template.Must(template.New("rewrites").Parse(rewritesPklTemplate))

// rewritesDir returns ~/.pkl/pkl-proxy/, creating it if needed.
func rewritesDir() (string, error) {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return "", fmt.Errorf("getting home directory: %w", err)
	}
	dir := filepath.Join(homeDir, ".pkl", "pkl-proxy")
	if err := os.MkdirAll(dir, 0755); err != nil {
		return "", fmt.Errorf("creating rewrites directory: %w", err)
	}
	return dir, nil
}

func rewritesFilePath() (string, error) {
	dir, err := rewritesDir()
	if err != nil {
		return "", err
	}
	return filepath.Join(dir, "rewrites.pkl"), nil
}

func settingsFilePath() (string, error) {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return "", fmt.Errorf("getting home directory: %w", err)
	}
	return filepath.Join(homeDir, ".pkl", "settings.pkl"), nil
}

// normalizePath strips URL prefixes to extract the github user[/repo] path.
// e.g. "https://pkg.pkl-lang.org/github.com/joesmith/repo" -> "joesmith/repo"
func normalizePath(input string) (string, error) {
	s := input
	s = strings.TrimPrefix(s, "https://")
	s = strings.TrimPrefix(s, "http://")
	s = strings.TrimPrefix(s, "pkg.pkl-lang.org/")
	s = strings.TrimPrefix(s, "github.com/")
	s = strings.TrimSuffix(s, "/")

	if s == "" || strings.Contains(s, "://") {
		return "", fmt.Errorf("invalid github path: %s", input)
	}
	return s, nil
}

// readPaths reads the existing paths from the rewrites.pkl file.
func readPaths(filePath string) ([]string, error) {
	f, err := os.Open(filePath)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, nil
		}
		return nil, err
	}
	defer f.Close()

	var paths []string
	inPaths := false
	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if strings.HasPrefix(line, "local paths") {
			inPaths = true
			continue
		}
		if inPaths {
			if line == "}" {
				break
			}
			if strings.HasPrefix(line, `"`) && strings.HasSuffix(line, `"`) {
				paths = append(paths, strings.Trim(line, `"`))
			}
		}
	}
	return paths, scanner.Err()
}

func writeRewritesPkl(filePath string, listenAddress string, paths []string) error {
	f, err := os.Create(filePath)
	if err != nil {
		return fmt.Errorf("creating rewrites file: %w", err)
	}
	defer f.Close()

	return rewritesTmpl.Execute(f, struct {
		ListenAddress string
		Paths         []string
	}{
		ListenAddress: listenAddress,
		Paths:         paths,
	})
}

// pklEval runs "pkl eval" on a file to validate it. Returns any error output.
func pklEval(filePath string) error {
	cmd := exec.Command("pkl", "eval", filePath)
	out, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("pkl eval %s failed:\n%s", filePath, string(out))
	}
	return nil
}

func cmdInstall(input string) error {
	path, err := normalizePath(input)
	if err != nil {
		return err
	}

	configDir, err := findConfigDir()
	if err != nil {
		return err
	}
	config, err := loadConfig(configDir)
	if err != nil {
		return err
	}

	filePath, err := rewritesFilePath()
	if err != nil {
		return err
	}

	existing, err := readPaths(filePath)
	if err != nil {
		return fmt.Errorf("reading existing rewrites: %w", err)
	}

	for _, p := range existing {
		if p == path {
			fmt.Printf("Path %q is already installed\n", path)
			if !settingsHasProxy() {
				fmt.Println()
				fmt.Println("It looks like pkl-proxy rewrites are not wired into your Pkl settings.")
				fmt.Println("Run the following to enable them:")
				fmt.Println("  pkl-proxy settings install")
			}
			return nil
		}
	}

	paths := append(existing, path)
	if err := writeRewritesPkl(filePath, config.ListenAddress, paths); err != nil {
		return err
	}

	fmt.Printf("Installed %q\n", path)
	fmt.Printf("Rewrites written to %s\n", filePath)
	fmt.Println()
	fmt.Println("To enable rewrites in pkl, run:")
	fmt.Println("  pkl-proxy settings install")
	return nil
}

func cmdUninstall(input string) error {
	path, err := normalizePath(input)
	if err != nil {
		return err
	}

	configDir, err := findConfigDir()
	if err != nil {
		return err
	}
	config, err := loadConfig(configDir)
	if err != nil {
		return err
	}

	filePath, err := rewritesFilePath()
	if err != nil {
		return err
	}

	existing, err := readPaths(filePath)
	if err != nil {
		return fmt.Errorf("reading existing rewrites: %w", err)
	}

	found := false
	var paths []string
	for _, p := range existing {
		if p == path {
			found = true
			continue
		}
		paths = append(paths, p)
	}

	if !found {
		fmt.Printf("Path %q is not installed\n", path)
		return nil
	}

	if err := writeRewritesPkl(filePath, config.ListenAddress, paths); err != nil {
		return err
	}

	fmt.Printf("Uninstalled %q\n", path)
	fmt.Printf("Rewrites written to %s\n", filePath)
	return nil
}

func cmdSettingsInstall() error {
	filePath, err := settingsFilePath()
	if err != nil {
		return err
	}

	rewritesFile, err := rewritesFilePath()
	if err != nil {
		return err
	}

	// Check that rewrites.pkl exists
	if _, err := os.Stat(rewritesFile); os.IsNotExist(err) {
		return fmt.Errorf("no rewrites file found at %s\nRun 'pkl-proxy install <path>' first", rewritesFile)
	}

	// If settings.pkl doesn't exist, create it fresh
	if _, err := os.Stat(filePath); os.IsNotExist(err) {
		if err := os.MkdirAll(filepath.Dir(filePath), 0755); err != nil {
			return fmt.Errorf("creating pkl directory: %w", err)
		}
		if err := os.WriteFile(filePath, []byte(settingsPklTemplate), 0644); err != nil {
			return fmt.Errorf("writing settings.pkl: %w", err)
		}
		// Validate with pkl
		if err := pklEval(filePath); err != nil {
			return err
		}
		fmt.Printf("Created %s\n", filePath)
		return nil
	}

	// Settings exists â€” check if already wired up
	data, err := os.ReadFile(filePath)
	if err != nil {
		return fmt.Errorf("reading settings.pkl: %w", err)
	}
	content := string(data)

	if strings.Contains(content, "pklProxy.rewrites") {
		fmt.Println("pkl-proxy rewrites are already configured in settings.pkl")
		// Still check for conflicts
		return warnConflicts(filePath, content)
	}

	// Check for conflicts before modifying
	if err := warnConflicts(filePath, content); err != nil {
		return err
	}

	// Add import and for-loop
	importLine := `import "pkl-proxy/rewrites.pkl" as pklProxy`
	forBlock := "    for (key, value in pklProxy.rewrites) {\n      [key] = value\n    }"

	if !strings.Contains(content, importLine) {
		content = strings.Replace(content,
			`amends "pkl:settings"`,
			"amends \"pkl:settings\"\n\n"+importLine,
			1)
	}

	if strings.Contains(content, "rewrites {") {
		content = strings.Replace(content,
			"rewrites {",
			"rewrites {\n"+forBlock,
			1)
	} else if strings.Contains(content, "http {") {
		content = strings.Replace(content,
			"http {",
			"http {\n  rewrites {\n"+forBlock+"\n  }",
			1)
	} else {
		content += "\nhttp {\n  rewrites {\n" + forBlock + "\n  }\n}\n"
	}

	if err := os.WriteFile(filePath, []byte(content), 0644); err != nil {
		return fmt.Errorf("writing settings.pkl: %w", err)
	}

	// Validate with pkl
	if err := pklEval(filePath); err != nil {
		// Restore original on failure
		os.WriteFile(filePath, data, 0644)
		return fmt.Errorf("settings.pkl is invalid after modification (restored original):\n%w", err)
	}

	fmt.Printf("Updated %s\n", filePath)
	return warnConflicts(filePath, content)
}

func cmdSettingsUninstall() error {
	filePath, err := settingsFilePath()
	if err != nil {
		return err
	}

	data, err := os.ReadFile(filePath)
	if err != nil {
		if os.IsNotExist(err) {
			fmt.Println("No settings.pkl found, nothing to do")
			return nil
		}
		return fmt.Errorf("reading settings.pkl: %w", err)
	}

	content := string(data)
	if !strings.Contains(content, "pklProxy") {
		fmt.Println("pkl-proxy is not configured in settings.pkl")
		return nil
	}

	// Remove the import line
	content = strings.Replace(content, "\nimport \"pkl-proxy/rewrites.pkl\" as pklProxy\n", "\n", 1)

	// Remove the for-loop block
	lines := strings.Split(content, "\n")
	var filtered []string
	skipUntilClose := false
	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		if strings.Contains(trimmed, "pklProxy.rewrites") {
			skipUntilClose = true
			continue
		}
		if skipUntilClose {
			if trimmed == "}" {
				skipUntilClose = false
			}
			continue
		}
		filtered = append(filtered, line)
	}
	content = strings.Join(filtered, "\n")

	if err := os.WriteFile(filePath, []byte(content), 0644); err != nil {
		return fmt.Errorf("writing settings.pkl: %w", err)
	}

	// Validate with pkl
	if err := pklEval(filePath); err != nil {
		// Restore original on failure
		os.WriteFile(filePath, data, 0644)
		return fmt.Errorf("settings.pkl is invalid after modification (restored original):\n%w", err)
	}

	fmt.Printf("Removed pkl-proxy rewrites from %s\n", filePath)
	return nil
}

// settingsHasProxy checks if ~/.pkl/settings.pkl has pkl-proxy rewrites wired in.
func settingsHasProxy() bool {
	filePath, err := settingsFilePath()
	if err != nil {
		return false
	}
	data, err := os.ReadFile(filePath)
	if err != nil {
		return false
	}
	return strings.Contains(string(data), "pklProxy.rewrites")
}

// warnConflicts checks for manual rewrite entries that conflict with managed paths.
func warnConflicts(filePath, content string) error {
	rewritesFile, err := rewritesFilePath()
	if err != nil {
		return nil
	}
	managedPaths, err := readPaths(rewritesFile)
	if err != nil {
		return nil
	}

	var conflicts []string
	for _, p := range managedPaths {
		for _, prefix := range []string{
			fmt.Sprintf(`["https://github.com/%s/"]`, p),
			fmt.Sprintf(`["https://pkg.pkl-lang.org/github.com/%s/"]`, p),
		} {
			if strings.Contains(content, prefix) {
				conflicts = append(conflicts, prefix)
			}
		}
	}

	if len(conflicts) > 0 {
		fmt.Printf("\nWarning: %s contains manual rewrite entries that will conflict with pkl-proxy managed rewrites.\n", filePath)
		fmt.Println("Please remove these lines to avoid duplicate key errors:")
		for _, c := range conflicts {
			fmt.Printf("  %s = ...\n", c)
		}
		return fmt.Errorf("resolve conflicts in %s before continuing", filePath)
	}
	return nil
}
